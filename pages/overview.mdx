---
title: Overview
description: Simple primitives to build any layout with minimal custom CSS.
---

import { Box, Columns } from '@christiankaindl/lyts'
import Link from 'next/link'

export { default } from 'components/SidebarLayout/SidebarLayout'

1. Drop-in. Use as much or as little as you need, no complicated setup
1. Composable - Combine to create complex layouts
1. Familiar - Apply standard CSS flexbox and grid knowledge

## Layout as props

Getting to your desired layout should be as straightforward as possible. That's why LYTS exposes layout-specific functionality as props on its components. The Box component, which all others inherit, support a few handy props:

### Optical alignment: `bleed`

Sometimes what is technically aligned is not visually aligned to our eyes. For example, consider this button:
[[Example here]]

Technically, the button is aligned perfectly with the rest of the card, but its internal padding makes it look visually un-aligned. To fix this LYTS provides the `bleed` prop (and *Top/*Right/*Bottom/*Left), which makes it easy to nudge the button to the left, and "bleed" into the bounding box to visually align it:
[[Example here]]

<Columns collapseAt='30em'>
  <Box>
    Before
    <img />
  </Box>
  <Box>
    After
    <img />
  </Box>
</Columns>

### Vertical & horizontal alignment: `xAlign`/`yAlign`

CSS Flexbox provides `alignItems` and `justifyContent` to control alignment of children from the parent element. Depending on the flex-direction the control either the vertical or horizontal alignment, which can be quite confusing and easy to forget which does which.

LYTS normalizes this into "xAlign" and "yAlign" props which can be used on all components. Of course, manually setting alignItems/justifyContent still works as expected.

### Render as anything: `asChild`

By default, all LYTS components render a \<div> element. But if you use semantic HTML (which you should), you often want to change the rendered element to get the correct behaviors out-of-the-box (keyboard interactions, screen-readers).

Side note: The `asChild` API is inspired by Radix UI (we use their \<Slot /> component internally). It is an alternative to the commonly used `as` prop. `asChild` gives you more indentation, but composes in a clearer way with multiple `asChild` components.

## Server-side rendering

All components work out-of-the-box when rendering on the server. Container-based props such as Columns' `collapseAt` use CSS tequniques instead of resorting to a Resize Observer, which ensures that the first render on the client is always correct.

## Examples

Most apps and websites use the same types of layout primitives in their design. From navbars, cards, overlays, sidebars, breadcrumbs, etc. Most all of them are easily implemented with LYTS and a lot of them have examples you can copy/paste directly into your projects.

<Link href='/examples'>Check out all examples</Link>

## Compatability & browser support

LYTS uses the CSS `gap` property for spacing, which is supported by the vast majority of users' browsers. An earlier version used the negative margin technique to achive the same effect (with better browser support), but had some drawbacks:

- It renders 2 containers for every layout context
- Bleeding via margins only possible with another additional wrapper element

Layout components are used *a lot*, which can lead to a lot of unnecessary DOM elements on a page. The `gap` property is now well supported in browsers so the trade-off has been made to rely on it. Additionally, now negative `margin` values can be used to achieve visually align elements, like ghost buttons, easily.

## Aknowledgements

LYTS is the spiritual successor of [@quantargo/react-layout](https://github.com/quantargo/react-layout), which is used in production at [quantargo.com](https://www.quantargo.com). However there are quite a few adaptations and changes compared to it. Some of them, such moving from the negative margin technique to using native CSS `gap` are because of better browser support these days. Others, like various API changes and improvements, are based on extensive usage of the library.
